О СПИСКЕ СКАНИРУЕМЫХ ХОСТОВ
===========================
Основной таблицей, с которой работает администратор, является таблица блоков адресов.
Туда вносятся блоки в CIDR-нотации, в том числе и конкретные адреса (с маской /32),
а также какие login/password использовать. При этом можно указывать несколько записей для
одного и того же адреса, но с разными именами ресурсов - будет испоьлзован более подходящий
для конкретного uri. В качестве "более подходящего" сначала выбирается блок с совпадающим
именем ресурса (при нескольких совпадающих именах из них выбирается с наибольшей маской);
если подходящего имени/пароля среди найденных блоков не найдено или они не сработали,
выбирается имя/пароль с именем ресурса = null, с наибольшей маской блока.
	select user,pass from blocks
	where (resource = '$RESOURCE$' or resource = '')
	  and ($ADDRESS$ >= address_from and $ADDRESS$ <= address_till)
	order by resource desc, netmask desc

Сканер хостов читает таблицу блоков, формирует из них (с учетом приоритета) список всех
возможных адресов с заданием параметров входа на них или на их выборочные ресурсы,
и по этому списку производит сканирование файлов.

Поскольку нежелательно, а иногда и невозможно держать в памяти все обнаруженные хосты,
сброс данных в базу следует делать регулярно. Регулярность задается единицей (файл,
шара, хост, блок) и количеством единиц, после которых происход сброс в базу. Между сбросами в
базу данные хранятся в памяти.

Очевидно, что для полноценного сканирования потенциально пересекающихся блоков требуется,
чтобы сканер обращался к базе для проверки, был ли определенный хост/ресурс опрошен. Для
этого нужна либо отдельная таблица, заводимая на каждый сканер динамически, либо использовал
какие-то поля в основных таблицах. Для этих целей создадим поле "периодичность", задающее
количество секунд, в течение которых пересканировать шару не имеет смысла. Сканер, перебирая
все возможные адреса, предварительно проверяет время, когда нужная шара на нужном хосте
(если в переборе указана шара) или когда сам хост (если шара не указана) последний раз
сканировался. Если возраст данных больше периодичности, шара сканируется заново. В случае
успешного сканирования, информация о времени обновляется. В случае неуспешного - оставляется
без изменений с пометкой, что сейчас хост/шара выключены.

Сканирование должно идти по принципу "пачками". Одна пачка сканируется движком за раз
(условно, это может быть один каталог) и все элементы пачки с их данными (размер, тип, дата)
передаются в базу данных. При этом в базе помечаются как удаленные все элементы, принадлежащие
этому хосту/шаре/каталогу, которые не были переданы в пачке. Рекурсивный обход каталогов
организуется в самом движке, за счет того, что после очередной закидки на первом уровне,
выбираются все найденные каталоги, и в простом цикле for делается сканирование их содержимого.
Вопрос: как при этом исключить повторное сканирование каталогов первого уровня, когда делается
сканирование энного уровня?

Возможно, имеет смысл организовать рекурсивную процедуру в самом движке, которая сканиовала бы
каталог, закидывала данные в базу, а затем циклично пробегала по своим "деткам"-каталогам. Это
было бы более простое решение. Удаление уже несуществующих файлов просиходит по тому же принципу
"пачковости".

У сканированных хостов тогда не хранится информация о блоке, которому они принадлежат. Потому
что хост может быть в нескольких блоках, каждый из которых задает свои параметры входа. Блоки,
по логике, скорее являются "заказами" на сканирование, но не непосредственно блоками. Таким
образом, хост - первичная единица в дереве подчиненности. Адрес хоста является достаточным
идентификатором этого хоста. Но с учетом, что когда-нибудь возможно внедреине IPv6, адрес
хранится отдельным полем, а ключем является автогенерируемый код.

Выделение ресурса в отдельную сущность неуместно. Это обычный каталог по пути к файлу. Тогда
получаем только сущности хоста (характеризуется адресом, протоколом и логином - уникальный ключ),
и файлов (характеризуется хостом, путем и именем файла - уинкальный ключ). Смысл отдельных сущностей
был в том, чтобы некоторые ресурсы были доступны по отдельным паролям. Но это можно решить
дополнительным полем в таблице найденных хостов ("имя шары"). При этом на один хост может
приходиться несколько записей.

Сканер ресурсов может быть совмещен со сканером сети. Для этого выделяются две сущности - 
сам хост с данными об адресе и состоянии, и ресурс - набор протокола, порта, шары, юзера и
пароля для доступа к ресурсу. Причем ресурсами являются именно уникальные параметры входа.
Обычные ресурсы внутри хоста числятся как обыкновенные каталоги. Тогда же к хостам можно будет
цеплять и статистику пингов, маков, впн-сеансов и т.п.




О СКАНИРОВАНИИ ФАЙЛОВ
=====================
Сканер получает на вход список адресов с данными для входа, а также список данных для входа
на выборочные ресурсы этого адреса. Сканер пробегается по всем ним, и рекурсивно составляет
базу файлов с их stat-данными (размер, дата, тип...).

Если при сканировании обнаружился файл, которого нет в базе - он заносится.
Если есть и файл, и в базе - обновляется информация (если она изменилась).
После такого сканирования производится поиск по базе файлов, не обновленных в этом проходе
сканера, и они помечаются в базе как удаленные. В интерфейсе можно сделать специальную опцию
"поиск файлов, когда-либо существовавших". Информация о стертых файлах удаляется спустя
некоторое время (длительность памяти базы) - после сканирования всех хостов и ресурсов.


ПОИСК РЕСУРСОВ
==============
Когда в интерфейсе вводятся слова для поиска, из базы выбираются все записи о файлах и ресурсах
и хостах, содержащих в поле "имя" хотя бы одно из введенных слов. Затем каждой найденной записи
создается коэффициент релятивности по количеству совпавших слов из фразы и из имени файла.
Чем больше совпало - тем выше рейтинг. Можно использовать операцию сравнения строк, находящую
степень сходства (на уровне сервера базы данных, если такая там есть).






